<?php

namespace App\Controller;
use Cake\Log\Log;
use Cake\Network\Exception\ForbiddenException;

/**
 * Class SignaturesController
 * @package App\Controller
 */
class SignaturesController extends AppController {

	public function isAuthorized( $user ) {
		$perms = [
			'sign' => [
				'volunteer' => true,
				'committee' => true,
				'admin' => true,
			],
			'accept' => [
				'admin' => true,
				'committee' => true
			],
			'index' => [
				'volunteer' => true,
				'admin' => true,
				'committee' => true
			]
		];

		if( isset( $perms[ $this->request->getParam('action') ][ $user['role'] ]) ) {
			return $perms[ $this->request->getParam('action') ][ $user['role'] ];
		}

		return parent::isAuthorized( $user ); // TODO: Change the autogenerated stub
	}

	public function index() {
		$user_signatures = $this->Signatures->find('all', [
			'conditions' => [
				'Signatures.user_id' => $this->Auth->user('user_id')
			],
			'contain' => ['Documents']
		]);

		$this->set( compact('user_signatures') );
	}

	public function accept($signature_id) {
		$signature = null;
		if( $this->request->is(['PATCH']) ) {
			$signature = $this->Signatures->get($signature_id, ['contain' => ['Users', 'Documents']]);
			if( $signature->signed ) {

			} else {
				$signature->signed = true;
				$signature->signature_text = __('{0}/{1} accepted physical document on behalf of {2}/{3}', 
					$this->Auth->user('user_id'), // 0
					$this->Auth->user('username'), // 1
					$signature->user->user_id, // 2
					$signature->user->username // 3
				);

				if( $this->Signatures->save($signature) ) {
					Log::info( __('{0}/{1} accepted physical document `{5}` from {2}/{3} via IP address {6}; Electronic signature entered `{4}`', [
						$this->Auth->user('user_id'), // 0
						$this->Auth->user('username'), // 1
						$signature->user->user_id, // 2
						$signature->user->username, // 3
						$signature->signature_text, // 4
						$signature->document->title, // 5
						$_SERVER['REMOTE_ADDR'] // 6
					]), 'audit');
				}
				
			}
			$this->set('signature', $signature);
		}
		$this->set('_serialize', ['signature']);
	}

	public function sign($signature_id) {

		$user = $this->Signatures->Users->get( $this->Auth->user('user_id') );

		if( !$user->profile_complete ) {
			$this->Flash->error( __('Please complete your profile before signing documents') );
			return $this->redirect(['controller' => 'users', 'action' => 'me']);
		}

		$signature = $this->Signatures->find('all', [
			'conditions' => [
				'Signatures.user_id' => $this->Auth->user('user_id'),
				'Signatures.signature_id' => $signature_id,
				'Signatures.signed' => false
			],
			'contain' => ['Documents', 'Users']
		])->first();

		if( !$signature ) {
			throw new ForbiddenException( __('You have requested an invalid signature or you are unable to sign it.') );
		}

		if( $this->request->is( ['post', 'patch', 'put'] ) ) {
			$signature_text_expected = __("/s/ {0} {1}", [
				trim( strtoupper($signature->user->first_name) ),
				trim( strtoupper($signature->user->last_name) )
			]);

			if( $signature_text_expected ==  $this->request->getData('signature_text') ) {
				$signature = $this->Signatures->patchEntity($signature, $this->request->getData() );
				$signature['signed'] = true;
				if( $this->Signatures->save($signature) ) {

					Log::info( __('{0}/{1} entered electronic signature `{2}` on document `{3}` from IP address {4}', [
						$signature->user->user_id,
						$signature->user->username,
						$signature->signature_text,
						$signature->document->title,
						$_SERVER['REMOTE_ADDR']
					]), 'audit');
					$this->Flash->success( __('You successfully signed {0}', [$signature->document->title]));
					return $this->redirect(['action' => 'index']);
				}
			} else {
				$this->Flash->error( __('Your signature did not match the required format.') );
			}
		}

		$this->set( compact('user', 'signature') );
	}
}
